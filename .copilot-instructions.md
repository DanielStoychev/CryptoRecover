# GitHub Copilot Instructions for CryptoRecover Modernization
## Comprehensive Development Guidelines

**Project**: CryptoRecover Enhanced by Daniel Stoychev  
**Base**: BTCRecover (GPL v2.0) by Christopher Gurnee & 3rdIteration team  
**Version**: 2.0.0-Stoychev (target)  
**Language**: Python 3.9-3.13  
**License**: GPL v2.0  

---

## ðŸŽ¯ **PRIMARY OBJECTIVES**

### **Core Mission**
Transform CryptoRecover into a modern, comprehensive cryptocurrency recovery tool while maintaining:
- **Legal compliance** with GPL v2.0
- **Backward compatibility** with existing functionality
- **High code quality** and security standards
- **Comprehensive documentation** and testing

### **Success Metrics**
- Support for 50+ cryptocurrencies (current: ~40)
- Python 3.9-3.13 compatibility
- Zero security vulnerabilities
- 95%+ test coverage
- Professional documentation

---

## ðŸ“‹ **MANDATORY REFERENCE DOCUMENTS**

**ALWAYS consult these documents before any code changes:**

1. **`MODERNIZATION_PLAN.md`** - Master project roadmap and timeline
2. **`FEASIBILITY_RESEARCH.md`** - Technical feasibility of new features
3. **`FEASIBILITY_ANALYSIS.md`** - Detailed plan review and reality check
4. **`IMPLEMENTATION_PRIORITY.md`** - Quick reference for task prioritization

**Context7 Integration**: Use Context7 MCP tools extensively for:
- Research on cryptocurrency standards and libraries
- Documentation lookup for Bitcoin/Ethereum protocols
- Best practices for Python cryptographic libraries
- Security considerations for wallet recovery tools

---

## ðŸ”’ **LEGAL & LICENSING REQUIREMENTS**

### **GPL v2.0 Compliance - MANDATORY**
```python
# EVERY new Python file must start with:
"""
[Brief description of file purpose]

Copyright (C) 2025 Daniel Stoychev
Based on BTCRecover by Christopher Gurnee (2014-2017) and 3rdIteration team (2019-2021)

This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version
2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
"""
```

### **Attribution Requirements**
- **NEVER remove** existing copyright notices
- **ALWAYS add** Daniel Stoychev copyright for new code
- **PRESERVE** original author attribution in modified files
- **DOCUMENT** significant changes in CHANGELOG.md

---

## ðŸ›  **TECHNICAL STANDARDS**

### **Python Version Compatibility**
```python
# Target compatibility: Python 3.9-3.13
# Current environment: Python 3.12.6 âœ…

# Version check pattern (use in all main scripts):
import sys
if sys.version_info < (3, 9):
    print("Error: Python 3.9 or higher required")
    sys.exit(1)
```

### **Code Quality Standards**
- **Type hints**: Add to all new functions
- **Docstrings**: Required for all public functions/classes
- **Error handling**: Comprehensive try/catch blocks
- **Logging**: Use proper logging instead of print statements
- **Security**: Never log private keys or sensitive data

### **Dependency Management**
```txt
# Core dependencies (requirements.txt):
coincurve~=21.0.0      # Already updated âœ…
protobuf~=6.31.1       # Need to update
pycryptodome~=3.23.0   # Need to update
green~=3.3.0           # Current
sjcl~=0.2.1           # Current

# Full dependencies (requirements-full.txt):
# Add Context7-researched libraries as needed
```

---

## ðŸ” **SECURITY REQUIREMENTS**

### **Critical Security Rules**
1. **NEVER** hardcode private keys, seeds, or passwords
2. **ALWAYS** validate input parameters
3. **SECURE** memory handling for sensitive data
4. **AUDIT** all cryptographic operations
5. **TEST** with malformed/malicious inputs

### **Secure Coding Patterns**
```python
# Example: Secure input validation
def validate_mnemonic(mnemonic_words):
    """Validate mnemonic with comprehensive checks."""
    if not isinstance(mnemonic_words, (list, str)):
        raise TypeError("Mnemonic must be string or list")
    
    # Additional validation...
    
# Example: Secure memory handling
def clear_sensitive_data(data):
    """Securely clear sensitive data from memory."""
    if isinstance(data, str):
        data = '\x00' * len(data)
    elif isinstance(data, list):
        for i in range(len(data)):
            data[i] = None
```

---

## ðŸš€ **IMPLEMENTATION PRIORITIES**

### **Phase 1: Foundation (Weeks 1-2)**
1. **Legal compliance** - Update all copyright notices
2. **Fix syntax errors** - Systematic code review  
3. **Version standardization** - Consistent version strings
4. **Repository setup** - GitHub structure, CI/CD

### **Phase 2: Quick Wins (Weeks 3-4)**
```python
# Priority order for Ethereum L2 implementation:
ETHEREUM_L2_CHAINS = {
    'arbitrum': {
        'name': 'Arbitrum',
        'chain_id': 42161,
        'derivation_path': "m/44'/60'/0'/0",  # Same as Ethereum
        'address_format': 'ethereum',  # Reuse existing
        'priority': 1  # Highest
    },
    'optimism': {
        'name': 'Optimism', 
        'chain_id': 10,
        'derivation_path': "m/44'/60'/0'/0",
        'address_format': 'ethereum',
        'priority': 1
    },
    'base': {
        'name': 'Base',
        'chain_id': 8453,
        'derivation_path': "m/44'/60'/0'/0", 
        'address_format': 'ethereum',
        'priority': 1
    },
    'polygon_zkevm': {
        'name': 'Polygon zkEVM',
        'chain_id': 1101,
        'derivation_path': "m/44'/60'/0'/0",
        'address_format': 'ethereum', 
        'priority': 1
    }
}
```

### **Phase 3: Standards Implementation**
```python
# BIP85 implementation priority
BIP85_APPLICATIONS = {
    'mnemonic': {
        'app_number': 39,
        'description': 'BIP39 mnemonic derivation',
        'priority': 1
    },
    'hex': {
        'app_number': 2,
        'description': 'Hex entropy derivation',
        'priority': 2
    }
}
```

---

## ðŸ“š **CONTEXT7 USAGE GUIDELINES**

### **When to Use Context7**
- **Before implementing** any new cryptocurrency support
- **When researching** cryptographic standards (BIP, EIP, etc.)
- **For understanding** wallet formats and derivation paths
- **To find** Python libraries for blockchain integration
- **When troubleshooting** cryptographic implementations

### **Context7 Query Patterns**
```python
# Research pattern for new cryptocurrency:
# 1. "resolve-library-id": Search for Python SDK
# 2. "get-library-docs": Get implementation details
# 3. Focus on: seed derivation, address generation, testing

# Example queries:
# - "arbitrum python SDK wallet recovery"
# - "BIP85 deterministic entropy implementation" 
# - "ethereum layer 2 wallet compatibility"
# - "cardano native asset python library"
```

---

## ðŸ§ª **TESTING REQUIREMENTS**

### **Test Coverage Standards**
- **Unit tests**: Every new function
- **Integration tests**: Cryptocurrency support
- **End-to-end tests**: Full recovery workflows
- **Security tests**: Malformed input handling
- **Performance tests**: Large-scale operations

### **Test Structure**
```python
# File: tests/test_ethereum_l2.py
import unittest
from unittest.mock import patch, MagicMock

class TestEthereumL2Support(unittest.TestCase):
    """Test Ethereum Layer 2 cryptocurrency support."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.test_mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about"
        self.expected_addresses = {
            'arbitrum': '0x...',
            'optimism': '0x...',
            'base': '0x...'
        }
    
    def test_arbitrum_address_generation(self):
        """Test Arbitrum address generation from mnemonic."""
        # Implementation using Context7-researched methods
        pass
    
    def test_cross_l2_compatibility(self):
        """Test that L2 addresses match Ethereum addresses."""
        # Verify Ethereum L2 compatibility
        pass
```

---

## ðŸ“ **DOCUMENTATION STANDARDS**

### **Code Documentation**
```python
def recover_ethereum_l2_wallet(mnemonic: str, chain: str, derivation_path: str = None) -> dict:
    """
    Recover Ethereum Layer 2 wallet from mnemonic phrase.
    
    This function supports Arbitrum, Optimism, Base, and Polygon zkEVM
    recovery using standard Ethereum derivation paths.
    
    Args:
        mnemonic (str): BIP39 mnemonic phrase (12-24 words)
        chain (str): L2 chain name ('arbitrum', 'optimism', 'base', 'polygon_zkevm')
        derivation_path (str, optional): Custom derivation path. 
                                       Defaults to "m/44'/60'/0'/0"
    
    Returns:
        dict: Recovery results containing addresses and private keys
        
    Raises:
        ValueError: If mnemonic is invalid or chain unsupported
        CryptographicError: If key derivation fails
        
    Example:
        >>> result = recover_ethereum_l2_wallet(
        ...     "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about",
        ...     "arbitrum"
        ... )
        >>> print(result['addresses'][0])
        0x9858EfFD232B4033E47d90003D41EC34EcaEda94
        
    Note:
        Ethereum L2 chains use identical derivation to Ethereum mainnet.
        Private keys are compatible across all Ethereum-based chains.
    """
```

### **User Documentation**
- **README.md**: Updated with new features
- **TUTORIAL.md**: Step-by-step usage examples
- **FAQ.md**: Common questions and troubleshooting
- **CHANGELOG.md**: Detailed change documentation

---

## ðŸ”§ **DEVELOPMENT WORKFLOW**

### **Feature Development Process**
1. **Research**: Use Context7 to understand requirements
2. **Design**: Plan implementation approach  
3. **Implement**: Write code following standards
4. **Test**: Comprehensive testing suite
5. **Document**: Update all relevant documentation
6. **Review**: Self-review using this guide
7. **Integrate**: Merge with proper attribution

### **Git Workflow**
```bash
# Branch naming convention:
feature/ethereum-l2-support
bugfix/seedrecover-syntax-error  
docs/update-installation-guide
security/input-validation

# Commit message format:
[type]: brief description

[optional body explaining what and why]

# Examples:
feat: add Arbitrum wallet recovery support
fix: correct syntax error in seedrecover.py
docs: update README with new L2 chain support
security: add input validation for mnemonic phrases
```

---

## ðŸš¨ **ERROR HANDLING PATTERNS**

### **Exception Hierarchy**
```python
class CryptoRecoverError(Exception):
    """Base exception for CryptoRecover."""
    pass

class WalletRecoveryError(CryptoRecoverError):
    """Raised when wallet recovery fails."""
    pass

class InvalidMnemonicError(CryptoRecoverError):
    """Raised when mnemonic validation fails."""
    pass

class UnsupportedChainError(CryptoRecoverError):
    """Raised when cryptocurrency chain is not supported."""
    pass

class CryptographicError(CryptoRecoverError):
    """Raised when cryptographic operations fail."""
    pass
```

### **Error Handling Best Practices**
```python
def safe_wallet_operation(operation_func, *args, **kwargs):
    """Safely execute wallet operations with proper error handling."""
    try:
        return operation_func(*args, **kwargs)
    except InvalidMnemonicError as e:
        logger.error(f"Invalid mnemonic provided: {e}")
        raise
    except CryptographicError as e:
        logger.error(f"Cryptographic operation failed: {e}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in wallet operation: {e}")
        raise WalletRecoveryError(f"Recovery failed: {e}")
```

---

## âš¡ **PERFORMANCE GUIDELINES**

### **Optimization Priorities**
1. **Memory usage**: Efficient handling of large wordlists
2. **CPU usage**: Optimized cryptographic operations
3. **I/O operations**: Minimize disk access
4. **Scalability**: Support for parallel processing

### **Performance Patterns**
```python
# Memory-efficient iteration
def process_large_wordlist(wordlist_path):
    """Process large wordlists without loading entire file."""
    with open(wordlist_path, 'r') as f:
        for line in f:
            yield line.strip()

# Parallel processing
from concurrent.futures import ThreadPoolExecutor

def parallel_address_generation(mnemonics, chain_configs):
    """Generate addresses in parallel for multiple chains."""
    with ThreadPoolExecutor(max_workers=4) as executor:
        futures = []
        for mnemonic in mnemonics:
            for chain in chain_configs:
                future = executor.submit(generate_address, mnemonic, chain)
                futures.append(future)
        
        return [future.result() for future in futures]
```

---

## ðŸŽ¯ **SPECIFIC IMPLEMENTATION GUIDANCE**

### **Ethereum L2 Implementation**
```python
# Pattern for adding new Ethereum L2 chain:
def add_ethereum_l2_chain(chain_name, chain_id, rpc_url=None):
    """
    Add support for new Ethereum L2 chain.
    
    Since all Ethereum L2s use identical wallet derivation,
    this primarily involves configuration rather than new crypto code.
    """
    
    # 1. Add chain configuration
    ETHEREUM_L2_CHAINS[chain_name] = {
        'name': chain_name.title(),
        'chain_id': chain_id,
        'derivation_path': "m/44'/60'/0'/0",  # Standard Ethereum path
        'address_format': 'ethereum',
        'rpc_url': rpc_url
    }
    
    # 2. Add to supported chains list
    SUPPORTED_CHAINS.append(chain_name)
    
    # 3. Update documentation
    # 4. Add tests
```

### **BIP85 Implementation Approach**
```python
# BIP85 requires careful implementation - use Context7 for research
def implement_bip85_entropy_derivation():
    """
    Implement BIP85 deterministic entropy derivation.
    
    Research requirements using Context7:
    1. BIP85 specification details
    2. HMAC-SHA512 implementation patterns
    3. Existing Python libraries for BIP85
    4. Test vectors for validation
    """
    
    # Implementation to be researched using Context7
    pass
```

---

## ðŸ“‹ **QUALITY CHECKLIST**

### **Before Any Commit**
- [ ] **Legal**: GPL v2.0 headers present
- [ ] **Security**: No hardcoded secrets
- [ ] **Testing**: Tests pass locally
- [ ] **Documentation**: Updated for changes
- [ ] **Performance**: No obvious inefficiencies
- [ ] **Compatibility**: Works on Python 3.9-3.13
- [ ] **Style**: Follows project conventions

### **Before Any Release**
- [ ] **Comprehensive testing** across all platforms
- [ ] **Security review** of all changes
- [ ] **Documentation** is complete and accurate
- [ ] **Performance benchmarks** meet standards
- [ ] **Legal compliance** verified
- [ ] **Changelog** updated with all changes

---

## ðŸŽ¯ **FINAL REMINDERS**

### **Always Remember**
1. **Consult reference documents** before major changes
2. **Use Context7** for research and documentation
3. **Prioritize security** over convenience
4. **Test thoroughly** with real-world scenarios  
5. **Document everything** for future maintainers
6. **Respect the GPL v2.0** license requirements
7. **Build incrementally** with regular testing

### **When in Doubt**
1. **Check** MODERNIZATION_PLAN.md for guidance
2. **Research** using Context7 tools
3. **Test** in isolated environment first
4. **Document** your decision-making process
5. **Ask** for clarification rather than assuming

---

**Instructions Version**: 1.0  
**Created**: July 24, 2025  
**For**: CryptoRecover Enhanced by Daniel Stoychev  
**Status**: âœ… **Active - Use for All Development**

---

## ðŸš€ **IMMEDIATE NEXT STEPS**

1. **Fix syntax errors** throughout codebase
2. **Update copyright notices** in all files
3. **Implement Ethereum L2 support** (highest priority)
4. **Use Context7** for BIP85 research
5. **Follow this guide** for all development decisions

**Remember**: This document is your primary reference - consult it for every development decision!
